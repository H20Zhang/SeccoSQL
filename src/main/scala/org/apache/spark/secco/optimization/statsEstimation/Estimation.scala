package org.apache.spark.secco.optimization.statsEstimation

import org.apache.spark.secco.optimization.LogicalPlan
import org.apache.spark.secco.optimization.plan.MultiwayJoin
import org.apache.spark.secco.trees.RuleExecutor

import scala.collection.mutable
import scala.collection.mutable.ArrayBuffer
import scala.math.BigDecimal.RoundingMode

trait Estimation[T] {
  def estimate(x: T): Option[Statistics]
}

object Estimation {
//
//  /** Merge all consecutive joins into one join. */
//  def mergeJoin(j: MultiwayJoin): LogicalPlan = {
//    val joinMergeExecutor = new RuleExecutor[LogicalPlan] {
//
//      override protected def batches: Seq[Batch] =
//        Seq(Batch("merge all joins", FixedPoint(999), MergeAllJoin))
//    }
//
//    joinMergeExecutor.execute(j)
//  }

  /** Check if each attribute has column stat in the corresponding statistics. */
  def columnStatsExist(statsAndAttr: (Statistics, String)*): Boolean = {
    statsAndAttr.forall { case (stats, attr) =>
      stats.attributeStats.contains(attr)
    }
  }

  /** Check if each attribute has column stat containing distinct and null counts
    *  in the corresponding statistic.
    */
  def columnStatsWithCountsExist(
      statsAndAttr: (Statistics, String)*
  ): Boolean = {
    statsAndAttr.forall { case (stats, attr) =>
      stats.attributeStats.get(attr).map(_.hasCountStats).getOrElse(false)
    }
  }

  /** Updates (scales down) the number of distinct values if the number of rows decreases after
    * some operation (such as filter, join). Otherwise keep it unchanged.
    */
  def updateNdv(
      oldNumRows: BigInt,
      newNumRows: BigInt,
      oldNdv: BigInt
  ): BigInt = {
    if (newNumRows < oldNumRows) {
      ceil(BigDecimal(oldNdv) * BigDecimal(newNumRows) / BigDecimal(oldNumRows))
    } else {
      oldNdv
    }
  }

  def ceil(bigDecimal: BigDecimal): BigInt =
    bigDecimal.setScale(0, RoundingMode.CEILING).toBigInt()

  /** Get column stats for output attributes. */
  def getOutputMap(
      inputMap: mutable.HashMap[String, ColumnStat],
      output: Seq[String]
  ): mutable.HashMap[String, ColumnStat] = {
    val stats = output.flatMap(a => inputMap.get(a).map(a -> _))
    mutable.HashMap(stats: _*)
  }

  /** Returns the index of the first bin into which the given value falls for a specified
    * numeric equi-height histogram.
    */
  private def findFirstBinForValue(
      value: Double,
      bins: Array[HistogramBin]
  ): Int = {
    var i = 0
    while ((i < bins.length) && (value > bins(i).hi)) {
      i += 1
    }
    i
  }

  /** Returns the index of the last bin into which the given value falls for a specified
    * numeric equi-height histogram.
    */
  private def findLastBinForValue(
      value: Double,
      bins: Array[HistogramBin]
  ): Int = {
    var i = bins.length - 1
    while ((i >= 0) && (value < bins(i).lo)) {
      i -= 1
    }
    i
  }

  /** Returns the possibility of the given histogram bin holding values within the given range
    * [lowerBound, upperBound].
    */
  private def binHoldingRangePossibility(
      upperBound: Double,
      lowerBound: Double,
      bin: HistogramBin
  ): Double = {
    assert(
      bin.lo <= lowerBound && lowerBound <= upperBound && upperBound <= bin.hi
    )
    if (bin.hi == bin.lo) {
      // the entire bin is covered in the range
      1.0
    } else if (upperBound == lowerBound) {
      // set percentage to 1/NDV
      1.0 / bin.ndv.toDouble
    } else {
      // Use proration since the range falls inside this bin.
      math.min((upperBound - lowerBound) / (bin.hi - bin.lo), 1.0)
    }
  }

  /** Returns the number of histogram bins holding values within the given range
    * [lowerBound, upperBound].
    *
    * Note that the returned value is double type, because the range boundaries usually occupy a
    * portion of a bin. An extreme case is [value, value] which is generated by equal predicate
    * `col = value`, we can get higher accuracy by allowing returning portion of histogram bins.
    *
    * @param upperBound the highest value of the given range
    * @param upperBoundInclusive whether the upperBound is included in the range
    * @param lowerBound the lowest value of the given range
    * @param lowerBoundInclusive whether the lowerBound is included in the range
    * @param bins an array of bins for a given numeric equi-height histogram
    */
  def numBinsHoldingRange(
      upperBound: Double,
      upperBoundInclusive: Boolean,
      lowerBound: Double,
      lowerBoundInclusive: Boolean,
      bins: Array[HistogramBin]
  ): Double = {
    assert(
      bins.head.lo <= lowerBound && lowerBound <= upperBound && upperBound <= bins.last.hi,
      "Given range does not fit in the given histogram."
    )
    assert(
      upperBound != lowerBound || upperBoundInclusive || lowerBoundInclusive,
      s"'$lowerBound < value < $upperBound' is an invalid range."
    )

    val upperBinIndex = if (upperBoundInclusive) {
      findLastBinForValue(upperBound, bins)
    } else {
      findFirstBinForValue(upperBound, bins)
    }
    val lowerBinIndex = if (lowerBoundInclusive) {
      findFirstBinForValue(lowerBound, bins)
    } else {
      findLastBinForValue(lowerBound, bins)
    }
    assert(lowerBinIndex <= upperBinIndex, "Invalid histogram data.")

    if (lowerBinIndex == upperBinIndex) {
      binHoldingRangePossibility(upperBound, lowerBound, bins(lowerBinIndex))
    } else {
      // Computes the occupied portion of bins of the upperBound and lowerBound.
      val lowerBin = bins(lowerBinIndex)
      val lowerPart =
        binHoldingRangePossibility(lowerBin.hi, lowerBound, lowerBin)

      val higherBin = bins(upperBinIndex)
      val higherPart =
        binHoldingRangePossibility(upperBound, higherBin.lo, higherBin)

      // The total number of bins is lowerPart + higherPart + bins between them
      lowerPart + higherPart + upperBinIndex - lowerBinIndex - 1
    }
  }

  /** Returns overlapped ranges between two histograms, in the given value range
    * [lowerBound, upperBound].
    */
  def getOverlappedRanges(
      leftHistogram: Histogram,
      rightHistogram: Histogram,
      lowerBound: Double,
      upperBound: Double
  ): Seq[OverlappedRange] = {
    val overlappedRanges = new ArrayBuffer[OverlappedRange]()
    // Only bins whose range intersect [lowerBound, upperBound] have join possibility.
    val leftBins = leftHistogram.bins
      .filter(b => b.lo <= upperBound && b.hi >= lowerBound)
    val rightBins = rightHistogram.bins
      .filter(b => b.lo <= upperBound && b.hi >= lowerBound)

    leftBins.foreach { lb =>
      rightBins.foreach { rb =>
        val (left, leftHeight) =
          trimBin(lb, leftHistogram.height, lowerBound, upperBound)
        val (right, rightHeight) =
          trimBin(rb, rightHistogram.height, lowerBound, upperBound)
        // Only collect overlapped ranges.
        if (left.lo <= right.hi && left.hi >= right.lo) {
          // Collect overlapped ranges.
          val range = if (right.lo >= left.lo && right.hi >= left.hi) {
            // Case1: the left bin is "smaller" than the right bin
            //      left.lo            right.lo     left.hi          right.hi
            // --------+------------------+------------+----------------+------->
            if (left.hi == right.lo) {
              // The overlapped range has only one value.
              OverlappedRange(
                lo = right.lo,
                hi = right.lo,
                leftNdv = 1,
                rightNdv = 1,
                leftNumRows = leftHeight / left.ndv,
                rightNumRows = rightHeight / right.ndv
              )
            } else {
              val leftRatio = (left.hi - right.lo) / (left.hi - left.lo)
              val rightRatio = (left.hi - right.lo) / (right.hi - right.lo)
              OverlappedRange(
                lo = right.lo,
                hi = left.hi,
                leftNdv = left.ndv * leftRatio,
                rightNdv = right.ndv * rightRatio,
                leftNumRows = leftHeight * leftRatio,
                rightNumRows = rightHeight * rightRatio
              )
            }
          } else if (right.lo <= left.lo && right.hi <= left.hi) {
            // Case2: the left bin is "larger" than the right bin
            //      right.lo           left.lo      right.hi         left.hi
            // --------+------------------+------------+----------------+------->
            if (right.hi == left.lo) {
              // The overlapped range has only one value.
              OverlappedRange(
                lo = right.hi,
                hi = right.hi,
                leftNdv = 1,
                rightNdv = 1,
                leftNumRows = leftHeight / left.ndv,
                rightNumRows = rightHeight / right.ndv
              )
            } else {
              val leftRatio = (right.hi - left.lo) / (left.hi - left.lo)
              val rightRatio = (right.hi - left.lo) / (right.hi - right.lo)
              OverlappedRange(
                lo = left.lo,
                hi = right.hi,
                leftNdv = left.ndv * leftRatio,
                rightNdv = right.ndv * rightRatio,
                leftNumRows = leftHeight * leftRatio,
                rightNumRows = rightHeight * rightRatio
              )
            }
          } else if (right.lo >= left.lo && right.hi <= left.hi) {
            // Case3: the left bin contains the right bin
            //      left.lo            right.lo     right.hi         left.hi
            // --------+------------------+------------+----------------+------->
            val leftRatio = (right.hi - right.lo) / (left.hi - left.lo)
            OverlappedRange(
              lo = right.lo,
              hi = right.hi,
              leftNdv = left.ndv * leftRatio,
              rightNdv = right.ndv,
              leftNumRows = leftHeight * leftRatio,
              rightNumRows = rightHeight
            )
          } else {
            assert(right.lo <= left.lo && right.hi >= left.hi)
            // Case4: the right bin contains the left bin
            //      right.lo           left.lo      left.hi          right.hi
            // --------+------------------+------------+----------------+------->
            val rightRatio = (left.hi - left.lo) / (right.hi - right.lo)
            OverlappedRange(
              lo = left.lo,
              hi = left.hi,
              leftNdv = left.ndv,
              rightNdv = right.ndv * rightRatio,
              leftNumRows = leftHeight,
              rightNumRows = rightHeight * rightRatio
            )
          }
          overlappedRanges += range
        }
      }
    }
    overlappedRanges
  }

  /** Given an original bin and a value range [lowerBound, upperBound], returns the trimmed part
    * of the bin in that range and its number of rows.
    * @param bin the input histogram bin.
    * @param height the number of rows of the given histogram bin inside an equi-height histogram.
    * @param lowerBound lower bound of the given range.
    * @param upperBound upper bound of the given range.
    * @return trimmed part of the given bin and its number of rows.
    */
  def trimBin(
      bin: HistogramBin,
      height: Double,
      lowerBound: Double,
      upperBound: Double
  ): (HistogramBin, Double) = {
    val (lo, hi) = if (bin.lo <= lowerBound && bin.hi >= upperBound) {
      //       bin.lo          lowerBound     upperBound      bin.hi
      // --------+------------------+------------+-------------+------->
      (lowerBound, upperBound)
    } else if (bin.lo <= lowerBound && bin.hi >= lowerBound) {
      //       bin.lo          lowerBound      bin.hi      upperBound
      // --------+------------------+------------+-------------+------->
      (lowerBound, bin.hi)
    } else if (bin.lo <= upperBound && bin.hi >= upperBound) {
      //    lowerBound            bin.lo     upperBound       bin.hi
      // --------+------------------+------------+-------------+------->
      (bin.lo, upperBound)
    } else {
      //    lowerBound            bin.lo        bin.hi     upperBound
      // --------+------------------+------------+-------------+------->
      assert(bin.lo >= lowerBound && bin.hi <= upperBound)
      (bin.lo, bin.hi)
    }

    if (hi == lo) {
      // Note that bin.hi == bin.lo also falls into this branch.
      (HistogramBin(lo, hi, 1), height / bin.ndv)
    } else {
      assert(bin.hi != bin.lo)
      val ratio = (hi - lo) / (bin.hi - bin.lo)
      (HistogramBin(lo, hi, math.ceil(bin.ndv * ratio).toLong), height * ratio)
    }
  }

  /** A join between two equi-height histograms may produce multiple overlapped ranges.
    * Each overlapped range is produced by a part of one bin in the left histogram and a part of
    * one bin in the right histogram.
    * @param lo lower bound of this overlapped range.
    * @param hi higher bound of this overlapped range.
    * @param leftNdv ndv in the left part.
    * @param rightNdv ndv in the right part.
    * @param leftNumRows number of rows in the left part.
    * @param rightNumRows number of rows in the right part.
    */
  case class OverlappedRange(
      lo: Double,
      hi: Double,
      leftNdv: Double,
      rightNdv: Double,
      leftNumRows: Double,
      rightNumRows: Double
  )

}
